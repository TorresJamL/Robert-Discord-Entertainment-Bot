import discord
from discord.ext import commands
from youtubesearchpython import VideosSearch
from yt_dlp import YoutubeDL
import os
import asyncio
import tracemalloc
import random
tracemalloc.start()
from die import dearth

#import all of the cogs
#from help_cog import help_cog
#from music_cog import music_cog

intents = discord.Intents.all()
client = commands.Bot(command_prefix='-', intents=intents)

#remove the default help command so that we can write out own
#bot.remove_command('help')

@client.command(pass_context = True)
async def join(ctx):
    if (ctx.author.voice):
        channel = ctx.message.author.voice.channel
        await channel.connect()
    else:
        await ctx.send('goofy')

@client.command(pass_context = True)
async def leave(ctx):
    if (ctx.voice_client):
        await ctx.guild.voice_client.disconnect()
        await ctx.send("Connection terminated. I'm sorry to interrupt you, Elizabeth, if you still even remember that name, But I'm afraid you've been misinformed. You are not here to receive a gift, nor have you been called here by the individual you assume, although, you have indeed been called. You have all been called here, into a labyrinth of sounds and smells, misdirection and misfortune. A labyrinth with no exit, a maze with no prize. ")
        await ctx.send("You don't even realize that you are trapped. Your lust for blood has driven you in endless circles, chasing the cries of children in some unseen chamber, always seeming so near, yet somehow out of reach, but you will never find them. None of you will. This is where your story ends. And to you, my brave volunteer, who somehow found this job listing not intended for you, although there was a way out planned for you, I have a feeling that's not what you want. I have a feeling that you are right where you want to be. ")
        await ctx.send("I am remaining as well. I am nearby. This place will not be remembered, and the memory of everything that started this can finally begin to fade away. As the agony of every tragedy should. And to you monsters trapped in the corridors, be still and give up your spirits. They don't belong to you. For most of you, I believe there is peace and perhaps more waiting for you after the smoke clears. Although, for one of you, the darkest pit of Hell has opened to swallow you whole, so don't keep the devil waiting, old friend. ")
        await ctx.send("My daughter, if you can hear me, I knew you would return as well. It's in your nature to protect the innocent. I'm sorry that on that day, the day you were shut out and left to die, no one was there to lift you up into their arms the way you lifted others into yours, and then, what became of you. I should have known you wouldn't be content to disappear, not my daughter. I couldn't save you then, so let me save you now. It's time to rest - for you, and for those you have carried in your arms. This ends for all of us. End communication.")
    else:
        await ctx.send('goofy')

@client.command(pass_context = True)
async def personalWorth(ctx):
    num = random.randint(1, 4)
    if num == 1:
        num = random.randint(1, 10_000)
        await ctx.send(f"{format(num, ',')}! You gonna stay on my dick until you die! You serve no purpose in life. Your purpose in life is being on my stream sucking on my dick daily! Your purpose is being in that chat blowing that dick daily! Your life is nothing! You serve zero purpose! You should kill yourself now! And give somebody else a piece of that oxygen and ozone layer, that's covered up so we can breathe inside this blue trapped bubble. Because what are you here for? To worship me? Kill yourself. I mean that, with a hundred percent. With a thousand percent.")
    elif num == 2:
        num = random.randint(10_000, 100_000)
        await ctx.send(f'{format(num, ',')}! I live in a low income housing environment that goes by the government name of "Section 8." Me and a group of my allies control certain areas of this section in order to run our illegitimate business. We possess unregistered firearms, stolen vehicles, mind-altering inhibitors and only use cash for financial purchases. If anyone would like to settle unfinished altercations, I will be more than happy to release my address. I would like to warn you; I am a very dangerous person and I regularly disobey the law."')
    elif num == 3:   
        num = random.randint(100_000, 100_000_000_000)
        await ctx.send(f"{format(num, ',')}! Ah, old chap, one simply can't help but revel in the sheer brilliance of opulence! I find myself surrounded by the finest of estates, adorned with the most exquisite trinkets. From my esteemed collection of rare antiques to the chauffeur-driven Rolls-Royce awaiting my every whim, one's affluence is truly the epitome of grandeur! Cheers!")
    else:
        num = random.randint(-100_000_000_000, 1)
        await ctx.send(f"{format(num, ',')}! Bloomin' 'ell, look at those toffs flaunting their wealth! Frolicking in their grand estates, sippin' champagne like it's tap water. Must be nice, eh? While the rest of us scrape by, they're livin' the high life, and I'm stuck here green with envy, cursin' their posh privileges.")

@client.command(pass_context = True)
async def randVC(ctx):
    if (ctx.author.voice):
        channel = ctx.message.author.voice.channel
        await channel.connect()
    else:
        await ctx.send('goofy')

    if ctx.guild.voice_client is None:
        return await ctx.send('I AINT EVEN THERE')

    voice_channel_id = ctx.guild.voice_client.channel.id
    await ctx.send(f'Voice Channel ID: {voice_channel_id}')

    voice_channel = discord.utils.get(ctx.guild.voice_channels, id=voice_channel_id)
    
    if not voice_channel:
        return await ctx.send('I give up')

    members = voice_channel.members

    if not members:
        return await ctx.send('Anybody Home?')

    random_member = random.choice(members)

    await ctx.send(f'Random User ID from the voice channel: {random_member.id}')
    await random_member.move_to(None)
    client.clear()

class MusicCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

        #all the music related stuff
        self.is_playing = False
        self.is_paused = False

        # 2d array containing [song, channel]
        self.music_queue = []
        self.YDL_OPTIONS = {'format': 'bestaudio/best'}
        self.FFMPEG_OPTIONS = {'options': '-vn'}

        self.vc = None
        self.ytdl = YoutubeDL(self.YDL_OPTIONS)
    async def play_next(self):
        if len(self.music_queue) > 0:
            self.is_playing = True

            #get the first url
            m_url = self.music_queue[0][0]['source']

            #remove the first element as you are currently playing it
            self.music_queue.pop(0)
            loop = asyncio.get_event_loop()
            data = await loop.run_in_executor(None, lambda: self.ytdl.extract_info(m_url, download=False))
            song = data['url']
            self.vc.play(discord.FFmpegPCMAudio(song, executable= "ffmpeg.exe", **self.FFMPEG_OPTIONS), after=lambda e: asyncio.run_coroutine_threadsafe(self.play_next(), self.bot.loop))
        else:
            self.is_playing = False

    async def play_music(self, ctx):
        if len(self.music_queue) > 0:
            self.is_playing = True

            m_url = self.music_queue[0][0]['source']
            #try to connect to voice channel if you are not already connected
            '''if self.vc == None or not self.vc.is_connected():
                voice_channel = ctx.author.voice.channel
                await voice_channel.connect()

                #in case we fail to connect
                if self.vc == None:
                    await ctx.send("```Could not connect to the voice channel```")
                    return
            else:
                voice_channel = ctx.author.voice.channel
                await voice_channel.connect()'''
            #remove the first element as you are currently playing it
            self.music_queue.pop(0)
            loop = asyncio.get_event_loop()
            data = await loop.run_in_executor(None, lambda: self.ytdl.extract_info(m_url, download=False))
            self.vc.play(discord.FFmpegPCMAudio(data['url'], executable= "ffmpeg.exe", **self.FFMPEG_OPTIONS), after=lambda e: asyncio.run_coroutine_threadsafe(self.play_next(), self.bot.loop))
            
        else:
            self.is_playing = False

    def search_yt(self, item):
            if item.startswith("https://"):
                title = self.ytdl.extract_info(item, download=False)["title"]
                return{'source':item, 'title':title}
            search = VideosSearch(item, limit=1)
            return{'source':search.result()["result"][0]["link"], 'title':search.result()["result"][0]["title"]}

    @commands.command(name="play", aliases=["p","playing"], help="Plays a selected song from youtube")
    async def play(self, ctx, *args):
        query = " ".join(args)
        if ctx.author.voice:  # No need for parentheses here
            voice_channel = ctx.author.voice.channel
            await voice_channel.connect()
        else:
            await ctx.send('goofy')
            return
        
        if self.is_paused:
            self.vc.resume()
        else:
            song = self.search_yt(query)
            if type(song) == type(True):
                await ctx.send("```Could not download the song. Incorrect format try another keyword. This could be due to playlist or a livestream format.```")
            else:
                if self.is_playing:
                    await ctx.send(f"**#{len(self.music_queue)+2} -'{song['title']}'** added to the queue")
                else:
                    await ctx.send(f"**'{song['title']}'** added to the queue")

                self.music_queue.append([song, voice_channel])
                if self.is_playing == False:
                    await self.play_music(ctx)

    @commands.command()
    async def shuffle(self, ctx, playlist_url):
        # Check if the user is in a voice channel
        if not ctx.author.voice:
            await ctx.send('You need to be in a voice channel to use this command.')
            return

        voice_channel = ctx.author.voice.channel

        # Connect to the voice channel
        if ctx.voice_client is None:
            await voice_channel.connect()

        # Extract information about the playlist
        loop = asyncio.get_event_loop()
        playlist_info = await loop.run_in_executor(None, lambda: self.ytdl.extract_info(playlist_url, download=False))

        # Check if the playlist is valid
        if 'entries' not in playlist_info:
            await ctx.send('Invalid playlist URL.')
            return

        # Shuffle the playlist entries
        shuffled_playlist = random.sample(playlist_info['entries'], len(playlist_info['entries']))

        # Add the shuffled playlist to the music queue
        for entry in shuffled_playlist:
            song = {'source': entry['url'], 'title': entry['title']}
            self.music_queue.append([song, voice_channel])

        # Start playing the shuffled playlist
        if not self.is_playing:
            await self.play_music(ctx)

# Create an instance of the MusicCog
musicCog = MusicCog(client)

# Run the bot
async def main():
    await client.add_cog(musicCog)
    await client.start(nah)

asyncio.run(main())
